<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.62">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/favicon.ico"><title>React Hook | web前端面试</title><meta name="description" content="React Hook出现的意义什么？解决了什么问题？">
    <link rel="preload" href="/interview/assets/style-a44f9669.css" as="style"><link rel="stylesheet" href="/interview/assets/style-a44f9669.css">
    <link rel="modulepreload" href="/interview/assets/app-42511d1c.js"><link rel="modulepreload" href="/interview/assets/hook.html-f8e022cd.js"><link rel="modulepreload" href="/interview/assets/hook.html-8eda15cb.js"><link rel="prefetch" href="/interview/assets/index.html-e42fbec5.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-1dcc31e6.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-d82004b3.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-020ef126.js" as="script"><link rel="prefetch" href="/interview/assets/algorithm.html-ac191834.js" as="script"><link rel="prefetch" href="/interview/assets/closure.html-bc155966.js" as="script"><link rel="prefetch" href="/interview/assets/debounce.html-2ef75015.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-b81bbd37.js" as="script"><link rel="prefetch" href="/interview/assets/events.html-9c711ae6.js" as="script"><link rel="prefetch" href="/interview/assets/fiber.html-69c8e091.js" as="script"><link rel="prefetch" href="/interview/assets/optimize.html-222aaa42.js" as="script"><link rel="prefetch" href="/interview/assets/reactVsVue.html-07712258.js" as="script"><link rel="prefetch" href="/interview/assets/redux.html-b2e71254.js" as="script"><link rel="prefetch" href="/interview/assets/setState.html-5d65e872.js" as="script"><link rel="prefetch" href="/interview/assets/useState.html-8a4a7c20.js" as="script"><link rel="prefetch" href="/interview/assets/vNode.html-9c6af47e.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-37df77f0.js" as="script"><link rel="prefetch" href="/interview/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-dfac23c6.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-5ab7209f.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-81403e80.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-a4358518.js" as="script"><link rel="prefetch" href="/interview/assets/algorithm.html-8659e609.js" as="script"><link rel="prefetch" href="/interview/assets/closure.html-8b6d403b.js" as="script"><link rel="prefetch" href="/interview/assets/debounce.html-a05ad7c5.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-8c566617.js" as="script"><link rel="prefetch" href="/interview/assets/events.html-feb1a461.js" as="script"><link rel="prefetch" href="/interview/assets/fiber.html-8a998c77.js" as="script"><link rel="prefetch" href="/interview/assets/optimize.html-3f272366.js" as="script"><link rel="prefetch" href="/interview/assets/reactVsVue.html-e91e9b6a.js" as="script"><link rel="prefetch" href="/interview/assets/redux.html-f22caab4.js" as="script"><link rel="prefetch" href="/interview/assets/setState.html-cdd6bba4.js" as="script"><link rel="prefetch" href="/interview/assets/useState.html-b6440ccd.js" as="script"><link rel="prefetch" href="/interview/assets/vNode.html-35145b3b.js" as="script"><link rel="prefetch" href="/interview/assets/index.html-aaa90a97.js" as="script"><link rel="prefetch" href="/interview/assets/404.html-2b9eb000.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/interview/" class=""><img class="logo" src="/interview/images/logo.png" alt="web前端面试"><span class="site-name can-hide">web前端面试</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/interview/README.md" class="sidebar-item sidebar-heading" aria-label="概总"><!--[--><!--]--> 概总 <!--[--><!--]--></a><!----></li><li><a href="/interview/css/README.md" class="sidebar-item sidebar-heading" aria-label="Css"><!--[--><!--]--> Css <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">Javascript <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview/javascript/" class="sidebar-item" aria-label="事件循环机制"><!--[--><!--]--> 事件循环机制 <!--[--><!--]--></a><!----></li><li><a href="/interview/javascript/debounce.html" class="sidebar-item" aria-label="防抖与节流"><!--[--><!--]--> 防抖与节流 <!--[--><!--]--></a><!----></li><li><a href="/interview/javascript/closure.html" class="sidebar-item" aria-label="闭包"><!--[--><!--]--> 闭包 <!--[--><!--]--></a><!----></li><li><a href="/interview/javascript/algorithm.html" class="sidebar-item" aria-label="编程"><!--[--><!--]--> 编程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">React、Vue <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/interview/react/" class="router-link-active sidebar-item" aria-label="React18"><!--[--><!--]--> React18 <!--[--><!--]--></a><!----></li><li><a href="/interview/react/events.html" class="sidebar-item" aria-label="合成事件"><!--[--><!--]--> 合成事件 <!--[--><!--]--></a><!----></li><li><a href="/interview/react/fiber.html" class="sidebar-item" aria-label="fiber架构"><!--[--><!--]--> fiber架构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/react/hook.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="React Hook"><!--[--><!--]--> React Hook <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/interview/react/hook.html#react-hook-出现的意义什么-解决了什么问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="React Hook 出现的意义什么？解决了什么问题？"><!--[--><!--]--> React Hook 出现的意义什么？解决了什么问题？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/react/hook.html#hooks-为什么不能在循环和判断中使用-hooks-是怎么实现的" class="router-link-active router-link-exact-active sidebar-item" aria-label="Hooks 为什么不能在循环和判断中使用，Hooks 是怎么实现的"><!--[--><!--]--> Hooks 为什么不能在循环和判断中使用，Hooks 是怎么实现的 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/react/hook.html#react-class-和-hook-的区别-hook-存在的意义是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="react class 和 hook 的区别，hook 存在的意义是什么"><!--[--><!--]--> react class 和 hook 的区别，hook 存在的意义是什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/react/hook.html#uselayouteffect-和-useeffect-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="useLayoutEffect 和 useEffect 的区别"><!--[--><!--]--> useLayoutEffect 和 useEffect 的区别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/interview/react/optimize.html" class="sidebar-item" aria-label="React 优化"><!--[--><!--]--> React 优化 <!--[--><!--]--></a><!----></li><li><a href="/interview/react/reactVsVue.html" class="sidebar-item" aria-label="React 和 Vue 的区别"><!--[--><!--]--> React 和 Vue 的区别 <!--[--><!--]--></a><!----></li><li><a href="/interview/react/redux.html" class="sidebar-item" aria-label="Redux"><!--[--><!--]--> Redux <!--[--><!--]--></a><!----></li><li><a href="/interview/react/setState.html" class="sidebar-item" aria-label="setState"><!--[--><!--]--> setState <!--[--><!--]--></a><!----></li><li><a href="/interview/react/useState.html" class="sidebar-item" aria-label="useSate"><!--[--><!--]--> useSate <!--[--><!--]--></a><!----></li><li><a href="/interview/react/vNode.html" class="sidebar-item" aria-label="VNode 是什么？什么是虚拟 DOM？"><!--[--><!--]--> VNode 是什么？什么是虚拟 DOM？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/interview/http/README.md" class="sidebar-item sidebar-heading" aria-label="Http"><!--[--><!--]--> Http <!--[--><!--]--></a><!----></li><li><a href="/interview/webpack/README.md" class="sidebar-item sidebar-heading" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h2 id="react-hook-出现的意义什么-解决了什么问题" tabindex="-1"><a class="header-anchor" href="#react-hook-出现的意义什么-解决了什么问题" aria-hidden="true">#</a> React Hook 出现的意义什么？解决了什么问题？</h2><p>React Hook 是 React 16.8 版本引入的一项重要特性，它的出现有以下意义和解决了一些问题：</p><ol><li><p>状态逻辑复用：在传统的 React 类组件中，为了共享状态逻辑，需要使用高阶组件 (Higher-Order Components) 或 render props 的方式，导致代码变得冗长和难以理解。React Hook 提供了 useState 和 useEffect 等钩子函数，使得可以在函数组件中方便地复用状态逻辑，避免了组件之间的嵌套和层层传递。</p></li><li><p>函数组件的增强：React Hook 允许开发人员在函数组件中使用状态和副作用，而不仅仅局限于类组件。这样，开发人员可以更自然地编写组件，无需关注类组件中的生命周期方法和类实例的特性。</p></li><li><p>更简洁的代码：相对于类组件，使用 React Hook 编写的代码通常更加简洁、易读和易维护。没有了繁琐的类声明和生命周期方法，代码结构更加扁平，组件的职责和功能更清晰明了。</p></li><li><p>避免了闭包陷阱：在类组件中，处理副作用时需要使用类实例变量或函数绑定来确保作用域的正确性。而 React Hook 使用函数闭包来管理状态和副作用，消除了类组件中常见的 this 绑定和上下文切换问题。</p></li><li><p>更好的性能优化：React Hook 的设计使得性能优化变得更加直观和容易。可以使用 useMemo 和 useCallback 来避免不必要的计算和函数重新创建，而不必依赖类组件中的 shouldComponentUpdate 方法。</p></li></ol><p>总的来说，React Hook 的出现使得 React 开发更加简洁、灵活和易用，提供了一种更现代化的组件编写方式。它解决了组件复用、函数组件的限制、代码冗余和性能优化等方面的问题，提升了开发效率和代码质量。</p><h2 id="hooks-为什么不能在循环和判断中使用-hooks-是怎么实现的" tabindex="-1"><a class="header-anchor" href="#hooks-为什么不能在循环和判断中使用-hooks-是怎么实现的" aria-hidden="true">#</a> Hooks 为什么不能在循环和判断中使用，Hooks 是怎么实现的</h2><p>Hooks 在循环、条件语句和嵌套函数中使用会引发一些问题，因为 Hooks 的设计依赖于其调用顺序的稳定性。这是由于 Hooks 使用了 React 的闭包机制来捕获和管理组件的状态。</p><ol><li><p>循环中使用：如果在循环中使用 Hooks，循环的每次迭代都会创建新的状态和副作用。这会导致 Hooks 的调用顺序不稳定，可能导致状态错乱和副作用的不正确执行。为了确保 Hooks 的稳定性和正确性，应在循环外部使用 Hooks。</p></li><li><p>条件语句中使用：如果在条件语句中使用 Hooks，由于条件的变化，Hooks 的调用顺序可能会发生变化。这可能导致状态的不一致和副作用的错误执行。为了避免这种问题，应该将条件语句放在 Hooks 调用之前，或者使用条件渲染的方式来控制 Hooks 的使用。</p></li></ol><p>Hooks 是通过 React 的闭包机制来实现的。在函数组件中，每次组件重新渲染时，React 会根据 Hooks 的调用顺序来恢复和管理组件的状态。Hooks 的实现机制包括以下几个关键步骤：</p><ol><li><p>钩子函数调用：在函数组件中，我们通过调用 Hooks 函数来声明和使用状态。例如，useState、useEffect 等。</p></li><li><p>状态捕获：Hooks 函数会在组件的作用域内被调用，并通过闭包机制捕获组件的状态。这意味着每个 Hooks 调用都有自己的状态，并与特定的组件实例相关联。</p></li><li><p>状态管理：React 使用内部的数据结构来跟踪每个 Hooks 的状态，并将其与组件实例关联起来。这样，在组件重新渲染时，React 可以根据 Hooks 的调用顺序找到正确的状态。</p></li><li><p>状态更新和副作用：当组件的状态发生变化时，React 会根据 Hooks 的依赖关系来确定是否需要重新计算状态和执行相关的副作用。这是通过比较前后两次 Hooks 的调用顺序和依赖关系来实现的。</p></li></ol><p>通过这种方式，React 实现了 Hooks 的稳定性和一致性。它使得我们可以在函数组件中声明和使用状态，而不需要使用类组件和生命周期方法。Hooks 提供了一种更简洁、可重用和可测试的方式来管理组件的状态和副作用。</p><h2 id="react-class-和-hook-的区别-hook-存在的意义是什么" tabindex="-1"><a class="header-anchor" href="#react-class-和-hook-的区别-hook-存在的意义是什么" aria-hidden="true">#</a> react class 和 hook 的区别，hook 存在的意义是什么</h2><p>React Class 组件和 React Hooks 是 React 中组件编写的两种不同方式，它们有以下区别：</p><ol><li><p>语法和写法：React Class 组件使用 ES6 的类语法来定义组件，需要继承自 React.Component，并使用生命周期方法来处理状态和副作用。而 React Hooks 则是使用函数组件的方式编写，可以直接在函数组件中使用 Hooks 函数来管理状态和副作用。</p></li><li><p>状态管理：在 React Class 组件中，状态管理需要使用 this.state 和 this.setState() 来声明和更新组件的状态。而 React Hooks 提供了一系列的 Hooks 函数（如 useState、useEffect 等），使得状态的声明和更新更加简洁和直观。</p></li><li><p>生命周期：React Class 组件提供了一系列生命周期方法（如 componentDidMount、componentDidUpdate 等）来处理组件的生命周期事件。而 React Hooks 使用 useEffect 来替代生命周期方法，可以在函数组件中处理组件的副作用和生命周期事件。</p></li><li><p>代码复用和可测试性：使用 React Hooks 编写的函数组件更加简洁、可重用和可测试。Hooks 提供了一种更纯粹的函数式编程方式，使得组件的逻辑更易于拆分、组合和测试。</p></li></ol><p>React Hooks 的存在意义是为了提供一种更简洁、灵活和可维护的方式来编写组件。相对于传统的 React Class 组件，Hooks 在以下方面具有优势：</p><ol><li><p>函数式编程：Hooks 使得组件的逻辑可以以函数的形式进行组合和复用，使得代码更加可读、可维护和可测试。</p></li><li><p>更小的学习曲线：相对于类组件和生命周期方法，Hooks 提供了一种更直观和简单的方式来管理状态和副作用，降低了学习和上手的难度。</p></li><li><p>更好的性能优化：Hooks 的异步渲染和增量更新机制使得 React 应用程序在性能方面更加灵活和高效。</p></li><li><p>更好的开发体验：Hooks 可以减少代码的冗余，使得组件的逻辑更加集中和清晰，提高了开发效率和代码质量。</p></li></ol><p>总的来说，React Hooks 提供了一种更现代、简洁和灵活的方式来编写 React 组件。它使得组件的状态管理和副作用处理更加直观和可控，同时提供了更好的性能和开发体验。</p><h2 id="uselayouteffect-和-useeffect-的区别" tabindex="-1"><a class="header-anchor" href="#uselayouteffect-和-useeffect-的区别" aria-hidden="true">#</a> useLayoutEffect 和 useEffect 的区别</h2><p>useEffect() 的作用就是指定一个副作用函数，组件每渲染一次，该函数就自动执行一次。 组件首次在网页 DOM 加载后，副效应函数也会执行。</p><ul><li>useEffect 是异步执行的，而 useLayoutEffect 是同步执行的。</li><li>useEffect 的执行时机是浏览器完成渲染之后，而 useLayoutEffect 的执行时机是浏览器把内容真正渲染到界面之前，和 componentDidMount 等价。</li></ul></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/interview/react/fiber.html" class="" aria-label="fiber架构"><!--[--><!--]--> fiber架构 <!--[--><!--]--></a></span><span class="next"><a href="/interview/react/optimize.html" class="" aria-label="React 优化"><!--[--><!--]--> React 优化 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/interview/assets/app-42511d1c.js" defer></script>
  </body>
</html>
